<!-- 趋势图 -->
<template>
  <div class="my-trend-chart box-shadow">
    <div
      class="select-none my-trend"
      v-for="(data, index) in trendData"
      :key="index"
      v-show="data.isShow"
    >
      <div :id="'screen-' + index"
        class="trend-chart"
        v-for="(item, idx) in data.chart"
        :key="item.chartId"
        :style="setHeight(data.chart)"
        @drop="addPos(idx, $event)"
        @dragover.prevent
      >
        <div class="trend-pos-list radius">
          <div class="trend-left-list">
            <span
              class="trend-eigenvalue"
              @click="switchEigenvalue($event, item)"
            >{{ item.eName }}</span>
            <span
              class="trend-close-chart"
              @click="closeOneChart(index, idx, item.chartId)"
            >
              <i class="iconfont icon-cuohao"></i>
            </span>
          </div>
          <div
            class="trend-left-list"
            v-for="(pos, id) in item.data"
            :key="id"
            @mousedown="removePos($event, item.data, id)"
            @contextmenu.prevent="contextmenu($event, item.data, id)"
          >
            <span :title="`${pos.pos.dgm_name}-${pos.name}`">{{
              pos.name
            }}</span>
            <span
              class="set-color"
              ref="changeColor"
              @click="setColor(index, idx, id, $event)"
              :style="'background-color:' + pos.color"
            ></span>
          </div>
        </div>
        <div
          class="trend-chart-view"
          :id="item.chartId"
          @contextmenu.prevent="showMenu(item.MenuShowflag, idx)"
        >
          <!-- 右击列表 -->
          <ul
            class="clickRightMenu"
            id="clickRightMenu"
            :ref="idx"
            v-show="item.MenuShowflag"
          >
            <!-- <li>显示/影藏转速</li> -->
            <li @click.stop="dataInput(idx)">
              <i class="iconfont icon-exportdata_huaban"></i>数据导出
            </li>
            <li @click.stop="savePic(idx)">
              <i class="iconfont icon-savemage_huaban"></i>保存
            </li>
          </ul>
        </div>
      </div>
      <div class="search-data">
        <button
          class="addPosTrend"
          @click="addTrend('new')"
        >新增图谱</button>
        <button
          @click="realBtn"
          class="get-real-data"
          :class="{ 'no-real-date': !trendData[currentKey].realBtn }"
        >
          实时数据
        </button>
        <button
          @click="getWave"
          :class="{ 'no-real-date': !trendData[currentKey].getWave }"
        >
          波形
        </button>
        <button @click="dataRetrieval">数据检索</button>
      </div>
    </div>
  </div>
</template>
<script>
import json2csv from 'json2csv'
import html2canvas from 'html2canvas'
import myChart from '@/assets/js/myCharts.js'
import {
  getCodeObj,
  cloneObj,
  getdefaultCode,
  getUnit,
  setHead,
  getTime,
  matchRule,
} from 'utils/utils.js'
import { log } from 'three'
export default {
  name: 'trend',
  data() {
    return {
      currentKey: '' /* 当前显示趋势图索引 */,
      positionMsg: null /* 需显示测点信息 */,
      trendData: {} /* 图谱的数据信息 */,
      /* {
           trend_pos_19070310412255376_0_3(key):{
             isShow:true; 图谱的显示
             cond:[] 每个图谱对应的工况
             chart:[ 一个图谱的图层
               {
                 code:2000 特征值
                 count:1 一个图层对应几个测点
                 type:3
                 value:"vib_rms"
                 data:{保存每个测点的值
                   19070310412255376_0_3:{
                      alarm:Object
                      color:"#000000"
                      name:"vib_09"
                      pos:Object
                      tendencyList:Array[4283]
                   }
                 }
               }
             ]
           }
         }*/
      sourceData: [
        /* 图谱数据信息 */
      ],
      requestData: {} /* 请求数据的结构 */,
      timer: [], //实时数据定时器存储的位置
      charts: {} /* myCharts */,
      units: [] /* y轴单位 */,
      chartOptionColor: {
        /* 图谱option颜色 */
        axis: {
          /* 坐标轴 */
          name: '#666' /* 标题 */,
          font: '#666' /* 字体 */,
          line: '#B3B3B3' /* 轴线 */,
          splitLine: '#ccc' /* 坐标轴分割线 */,
        },
        tool: {
          symbol: '#6C91DD' /* 圆点 */,
          line: '#6C91DD' /* 标线 */,
          font: '#fff' /* 字体 */,
          background: 'rgba(108, 145, 221, 0.8)' /* 背景 */,
        },
        series: {
          /* 图谱 */
          symbol: '#fff' /* symbol */,
        },
      },
      // colorList: [
      //   '#000000',
      //   '#CCCC00',
      //   '#993366',
      //   '#00CC99',
      //   '#996666',
      //   '#6666FF',
      //   '#999699',
      //   '#CC9933',
      // ] /* 备选颜色 */,
      checkColor: [] /* 设置颜色的位置下标 */,
      // MenuShowflag:{},/* 是否显示右键菜单 */
      timer: null, //全局定时器，针对多个chart的请求，只更新一次图谱
    }
  },
  watch: {
    '$store.state.trendMsg': {
      handler(value) {
        Object.keys(this.requestData).length === 0 && this.initSrcParams()
        if (value.length !== 0) {
          while (value.length) {
            let item = value.shift()
            this.openChartList(item.key, item.state)
          }
        }
      },
      deep: true,
      immediate: true,
    },
    '$store.state.structure'() {
      //监听structure的变化
      this.$nextTick(this.resizeChart)
    },
  },
  methods: {
    initSrcParams() {
      const params = this.$store.state.srcParams
      const time = params.time
      const speed = params.speed
      const limit = params.limit
      const density = params.density
      // const fileds = defaultCode[posType];
      this.requestData = {
        startTime: time.start,
        endTime: time.end,
        toSpeed: speed.max,
        fromSpeed: speed.min,
        lowerLimit: limit.lower,
        upperLimit: limit.upper,
        density: Number(density.type),
        dataType: [1], //8000数据类型
      }
    },
    //移除测点
    removePos(event, data, key) {
      if (event.button === 1) {
        this.$delete(data, key)
        this.setOption()
      }
    },
    //右键删除测点
    contextmenu(e, data, key) {
      let text = [{ type: 'del', val: '删除' }]
      const size = e.currentTarget.getBoundingClientRect()
      this.$list({
        text,
        pattern: {
          maxHeight: '400px',
          width: `${size.width - 40}px`,
          left: `${size.left + 50}px`,
          top: `${size.top + size.height + 3}px`,
        },
      }).then((res) => {
        if (res.item && res.item.type == 'del') {
          this.$delete(data, key)
          this.setOption()
        }
      })
    },
    //切换显示波形
    getWave() {
      let getWave = this.trendData[this.currentKey].getWave
      getWave = getWave === 0 ? 1 : 0 //在0和1之间切换
      this.trendData[this.currentKey].getWave = getWave
      this.setOption()
    },
    //切换特征值
    switchEigenvalue(event, chart) {
      let text = []
      var head = {}
      // head为通过setHead获取到的特征值
      if (chart.type == 13) {
        head = setHead(chart.t_root, chart.dgm_type, chart.type, chart.pos_loc)
      } else {
        head = setHead(chart.t_root, chart.dgm_type, chart.type)
      }
      head.forEach((item) => {
        if (item.filed == 'saveTime_Com' || item.filed == 'time') return
        if (item.val instanceof Array) {
          item.val = item.val[0] /* 合成倾角多个特征值暂时不选择 */
        }
        text.push({
          filed: item.filed,
          code: item.code,
          val: item.val,
        })
      })
      const size = event.target.getBoundingClientRect()
      let clientWidth = document.documentElement.clientHeight
      let top
      if (size.top + size.height + 200 > clientWidth) {
        top = size.top - 200 + 'px'
      } else {
        top = size.top + size.height + 'px'
      }
      this.$list({
        text,
        pattern: {
          maxHeight: '200px',
          top: top,
          left: size.left + 'px',
          width: size.width + 26 + 'px',
        },
      }).then((res) => {
        if (res.index !== -1) {
          chart.code = res.item.code
          chart.value = res.item.filed
          chart.eName = res.item.val
          this.getRequestParams()
        }
      })
    },
    // 打开趋势图
    openChartList(key, state) {
      if (typeof key !== 'string') return
      if (state === 0 || state == 1) {
        //新建图谱
        this.currentKey = key
        for (let k in this.trendData) {
          this.trendData[k].isShow = false
        }
      }
      switch (state) {
        case 0 /* 打开图表 */:
          this.$set(this.trendData, key, {
            chart: [], //每个tab包含的图谱
            cond: [], //每个tab自己的工况
            predTime: '', //趋势预测的时间
            alp: 0.2, //趋势预测的阈值
            realBtn: false, //实时数据按钮,默认是不开启
            getWave: 0, // 默认不获取波形
            timer: [], //实时数据请求的定时器,
            isShow: true,
            dataType: [
              { val: '定时历史数据', isChecked: true, type: 1 },
              { val: '启停机数据', isChecked: false, type: 2 },
              { val: '报警存储数据', isChecked: false, type: 3 },
            ], //8000数据类型选择
          })
          this.addTrend()
          break
        case 1 /* 切换图表 */:
          this.trendData[key].isShow = true
          for (let k = 0; k < this.trendData[key].chart.length; k++) {
            let chart = this.trendData[key].chart[k]
            if (!this.charts[chart.chartId]) {
              this.$nextTick(this.setOption())
              break
            }
          }
          this.$nextTick(this.resizeChart)
          break
        case 2 /* 关闭图表 */:
          this.closeAllCharts(key)
          break
      }
    },
    //关闭所有图谱
    closeAllCharts(key) {
      /* 1、清除定时器 */
      let trend = this.trendData[key]
      this.clearInterval(trend.timer)
      /* 2、删除chart实例 */
      trend.chart.forEach((item) => {
        this.$delete(this.charts, item.chartId) //删除chart实例
      })
      /* 3、删除这个图谱的组件 */
      delete this.trendData[key]
      if (Object.keys(this.trendData).length === 0) {
        this.$store.commit('set_keepAlive', {
          method: 'del',
          keepAlive: 'trend',
        })
      }
    },
    //添加图层
    addTrend(f) {
      // 按钮添加
      let macId, posId, posType
      /* 当前选中有测点 */
      let checkMsg = this.$store.state.checkMsg
      /* 按钮添加 并且 有选中的测点 */
      if (checkMsg.type === 'pos' && f === 'new') {
        macId = checkMsg.pos.machine_id
        posId = checkMsg.pos.position_id
        posType = checkMsg.pos.position_type
        let flag = matchRule(posType, 'trend')
        if (!flag) {
          this.$pop('不支持此类测点')
          return
        }
      } else {
        ;[, , macId, posId, posType] = this.currentKey.split('_')
      }
      let postions = this.$store.state.pos[macId] //获取当前机组下所有测点信息
      let posMsg
      /* 寻找当前测点信息 */
      postions.forEach((item) => {
        if (item.position_type == posType && item.position_id == posId) {
          posMsg = item
        }
      })
      const defaultCode = getdefaultCode(posMsg.dgm_type)
      let fileds = defaultCode[posType]
      let chart = this.trendData[this.currentKey].chart
      chart.push({
        count: 0,
        chartId: new Date().valueOf(), //每个图层的唯一标识
        type: posMsg.position_type /* 计算特征值 */,
        dgm_type: posMsg.dgm_type /* 计算特征值 */,
        t_root: posMsg.t_root /* 计算特征值 */,
        pos_loc: posMsg.pos_loc /* 计算特征值 */,
        code: fileds.code,
        value: fileds.filed,
        eName: fileds.name,
        data: {},
        MenuShowflag: false,
      })
      let key = `${macId}_${posId}_${posType}`
      let index = chart.length - 1
      this.add_pos(key, chart[index], posMsg)
    },
    //添加测点
    add_pos(key, chart, posMsg) {
      let chartDataLen 
      (chart.data) && (chartDataLen =  Object.keys(chart.data).length)
      let colorLen = this.colorList.length
      if(chartDataLen === 0) {
        colorLen = 1
      }
      else if(chartDataLen <= colorLen/2) {
        colorLen = colorLen / 2
      }
      //在实时数据开启的时候添加测点没做特殊处理
      let num = Math.floor(Math.random() * colorLen)
      let color = this.colorList[num]
      let pos_name = posMsg.position_name
      // 获取t_id
      const [macId, posId, posType] = posMsg.posFlag.split('_')
      let macmsg = this.$store.state.checkMsg.mac
      let t_id
      if (macmsg && macmsg.mac_id == macId) {
        t_id = macmsg.t_id
      } else {
        let macArray = this.$store.state.mac
        // 只是获取t_id，没有考虑机泵的情况取出的mac信息不一定准确
        for (let k in macArray) {
          for (let i = 0; i < macArray[k].length; i++) {
            let value = macArray[k][i]
            if (value.mac_id == macId) {
              t_id = k
            }
          }
        }
      }
      // 现场所有测点的趋势图纵坐标单位应和flex一样改为mm/s2
      const isMMS2 = bothConfig.mms2.indexOf(t_id.toString()) !== -1
      //创建一个测点的存储对象
      this.$set(chart.data, key, {
        color: color,
        name: pos_name,
        pos: posMsg,
        cond: [], //工况报警
        tendencyList: [],
        isMMS2: isMMS2 /* 趋势图单位是否要处理为mm/s2 */,
      })
      chart.count++ // 测点的计数+1
      // 如果是开启实时数据的话，就走实时数据的流程

      if (this.trendData[this.currentKey].realBtn) {
        // 开启了实时数据
        this.getRequestParams(1)
      } else {
        this.getRequestParams()
      }
    },
    // 数据检索之后获得组织请求参数
    getRequestParams(type = 0, isResize) {
      this.clearPredPos() //清除所有预测数据的测点
      //type 0：历史数据，1；实时数据 2 趋势预测
      let requestData = {}
      let timers = this.trendData[this.currentKey].timer // 定时器库
      /* 如果是实时数据，先清除定时器 */
      if (type === 1) this.clearInterval(timers)
      let predTime = this.trendData[this.currentKey].predTime
      let alp = this.trendData[this.currentKey].alp
      this.trendData[this.currentKey].chart.forEach((item, index) => {
        let keyArr = []
        for (let k in item.data) {
          keyArr.push(`${item.data[k].pos.t_root}_${k}`)
        }
        requestData = {
          key: keyArr,
          isSave: 1,
          code: item.code,
          value: item.value,
        }
        Object.assign(requestData, this.requestData)
        if (type === 1) {
          // 克隆当前请求数据，历史数据一份，实时数据一份
          let requestDataSave = cloneObj(requestData)
          let requestDataReal = cloneObj(requestData)
          /* 请求实时数据，先请求一小时的历史数据，再循环请求 */
          requestDataSave.startTime = new Date().valueOf() - 60 * 60 * 1000 //实时数据是获取一小时前面的数据
          requestDataSave.endTime = new Date().valueOf()
          requestDataReal.isSave = 0
          requestDataReal.isReal = 1
          // 先请求历史数据
          this.getData(item, requestDataSave, type)
          /* 再设置定时器请求实时数据 */
          let timer = setInterval(() => {
            let time = new Date().valueOf() //获取当前时间
            requestDataReal.time = time
            this.$getApi.getTendency(requestDataReal).then((res) => {
              if (!res) return
              this.realData(res, item)
            })
          }, 5000)
          timers.push(timer) // 存放所有定时器
          return
        } else if (type === 2) {
          requestData.isTrendPrediction = 1
          requestData.predictEndTime = predTime
          requestData.alp = alp
        }
        /* 多个chart 发送多个请求 */
        this.getData(item, requestData, type, isResize)
      })
    },
    /* 普通数据检索 发送网络请求 */
    getData(chart, requestData, type = 0, isResize) {
      this.$emit('loadingImg', true)
      this.$getApi.getTendency(requestData).then((res) => {
        this.$emit('loadingImg', false)
        if (res.msg === 0) {
          let data = res.data
          let flag = true //显示无数据
          for (let key in data) {
            let alarm = data[key].alarm || {}
            const cond = [
              {
                h: alarm.h_limit_1,
                hh: alarm.hh_limit_1,
                hhh: alarm.hhh_limit_1,
              },
              {
                h: alarm.h_limit_2,
                hh: alarm.hh_limit_2,
                hhh: alarm.hhh_limit_2,
              },
              {
                h: alarm.h_limit_3,
                hh: alarm.hh_limit_3,
                hhh: alarm.hhh_limit_3,
              },
              {
                h: alarm.h_limit_4,
                hh: alarm.hh_limit_4,
                hhh: alarm.hhh_limit_4,
              },
              {
                h: alarm.h_limit_5 || alarm.h_limit,
                hh: alarm.hh_limit_5 || alarm.hh_limit,
                hhh: alarm.hhh_limit_5 || alarm.hhh_limit,
                l: alarm.l_limit,
                ll: alarm.ll_limit,
              },
            ]
            let tendencyList = data[key].tendencyList
            if (tendencyList && tendencyList.length) {
              flag = false
            }
            let [mid, pid, ptype] = key.split('_')
            let k = `${mid}_${pid}_${ptype}`
            chart.data[k].tendencyList = tendencyList
            chart.data[k].cond = cond
            /* 添加趋势预测的测点 */
            if (data[key].hasTrendPredict == 1) {
              //含有趋势预测
              //创建一个虚拟的测点
              let tendencyList = this.transPredData(
                requestData.endTime,
                requestData.predictEndTime,
                data[key].trendPredict
              )
              let newKey = k + '_pred'
              this.$set(chart.data, newKey, {
                color: '#008F5A',
                pos: chart.data[k].pos,
                name: chart.data[k].name + '_pred',
                cond: cond,
                tendencyList: tendencyList,
              })
            } else if (data[key].hasTrendPredict == 0) {
              this.$pop('样本数量不足')
            }
          }
          if (type === 0 && flag) {
            this.$pop('此测点在搜索时间内无数据')
          }
          /* 多个chart 只更新一次 */
          clearTimeout(this.timer)
          this.timer = setTimeout(() => {
            this.setOption(isResize)
          }, 100)
        }
      })
    },
    // 实时数据按钮
    realBtn() {
      let obj = this.trendData[this.currentKey]
      obj.realBtn = !obj.realBtn
      if (!obj.realBtn) {
        this.clearInterval(obj.timer)
        this.getRequestParams()
        return
      }
      this.clearPredPos() // 清除存在的预测测点
      this.getRequestParams(1) //获取实时数据时先获取一段时间的历史数据
    },
    clearInterval(timer) {
      //暂时只在关闭全部页面 或者 关闭实时数据按钮时候统一清除，未对单个图层处理
      while (timer.length) {
        clearInterval(timer.pop())
      }
    },
    /* 处理实时数据 */
    realData(res, chart) {
      res = res.data
      let time = new Date().valueOf()
      for (let key in res) {
        let realInfo = res[key].realInfo
        if (realInfo) if (!realInfo) continue
        /* 清除1小时之前的历史数据 */
        let tendencyList = chart.data[key].tendencyList
        for (let i = tendencyList.length - 1; i >= 0; i--) {
          if (tendencyList[i].saveTime < time - 60 * 60 * 1000) {
            tendencyList.splice(i, 1)
          }
        }
        /* 加入新的数据 */
        tendencyList.push({
          saveTime: realInfo.saveTime,
          tempValue: realInfo[chart.value],
        })
      }
      if (!document.getElementsByClassName('trend-chart-view')[0]) return //切换到其他图谱的时候不更新，dom消失会导致将界面更新为空白。
      this.setOption()
    },
    // 设置option, 画图
    setOption(isResize = true) {
      //real 实时数据标志
      const charts = this.trendData[this.currentKey].chart
      const cond = this.trendData[this.currentKey].cond // 工况
      let getWave = this.trendData[this.currentKey].getWave
      let color = this.chartOptionColor
      let alarmArr = []
      for (let i = 0; i < charts.length; i++) {
        let chart = charts[i]
        let X = []
        let Y = []
        let XB = [] //有波形的数据点
        let Speed = []
        let unitY = []
        let chartData = chart.data
        let posName = []
        let seriesColor = []
        let pos_key_list = [] //存放所有的测点key ，到时候跳转波形的时候使用
        for (let key in chartData) {
          const value = chartData[key]
          let tendencyList = value.tendencyList
          if (tendencyList.length == 0) continue //如果没有数据，跳过
          let x = [],
            y = [],
            xb = [],
            speed = [],
            y1 = [] /* g,gD => mm/s2  存储转换单位为mm/s2的数据*/
          tendencyList.forEach((item, index) => {
            if (item.tempValue > 100000000) return
            x.push(item.saveTime)
            y.push(item.tempValue)
            speed.push(item.speed)
            if (
              value.isMMS2 &&
              (getUnit(chart.code, value.pos) == 'g' ||
                getUnit(chart.code, value.pos) == 'gD')
            ) {
              y1.push(item.tempValue * 9807)
            }
            /* 2000V1 的倾覆 给了数据 但其实是没有测点的 */
            if (value.pos.dgm_type == 1 && value.pos.position_type == 11) return
            if (item.waveLen == 1) {
              //0,没有，1，有 波形
              xb.push(item.saveTime)
            }
          })
          // 若需要转换单位将y1数据推入Y
          if (
            value.isMMS2 &&
            (getUnit(chart.code, value.pos) == 'g' ||
              getUnit(chart.code, value.pos) == 'gD')
          ) {
            Y.push(y1)
          } else {
            Y.push(y)
          }
          X.push(x)
          XB.push(xb)
          Speed.push(speed)
          pos_key_list.push({
            key,
            name: value.pos.mac_name + '-' + value.pos.position_name,
            wavePos: xb, //有波形的X值的集合
          }) //有数据的时候加入测点的key
          seriesColor.push(value.color)
          const pos = value.pos
          const type = pos.position_type
          posName.push(pos.position_name)
          if (pos.units) {
            if (value.isMMS2 && getUnit(chart.code, value.pos) == 'g') {
              unitY.push('mm/s²')
            } else {
              unitY.push(getUnit(chart.code, pos))
            }
          } else if (type === 12) {
            unitY.push('°')
          } else {
            unitY.push('') //没有单位 占一个位置
          }
          /* 设置工况 */
          cond.forEach((item, index) => {
            if (item.isShow) {
              // 显示工况
              let h = value.cond[index].h
              let hh = value.cond[index].hh
              let hhh = value.cond[index].hhh
              let l = value.cond[index].l
              let ll = value.cond[index].ll
              let t = function (e) {
                /* 存在有-1的情况 */
                if (e === -1 || e === '' || e === undefined) {
                  return null
                } else {
                  return e
                }
              }
              h = t(h)
              hh = t(hh)
              hhh = t(hhh)
              l = t(l)
              ll = t(ll)
              if (h) {
                alarmArr.push({
                  data: h,
                  lineStyle: {
                    color: '#C4C200',
                    width: 1,
                  },
                })
              }
              if (hh) {
                alarmArr.push({
                  data: hh,
                  lineStyle: {
                    color: '#ff0000',
                    width: 1,
                  },
                })
              }
              if (hhh) {
                alarmArr.push({
                  data: hhh,
                  lineStyle: {
                    color: '#ff0000',
                    width: 1,
                  },
                })
              }
              if (l) {
                alarmArr.push({
                  data: l,
                  lineStyle: {
                    color: '#C4C200',
                    width: 1,
                  },
                })
              }
              if (ll) {
                alarmArr.push({
                  data: ll,
                  lineStyle: {
                    color: '#ff0000',
                    width: 1,
                  },
                })
              }
            }
          })
        }
        // 设置option
        var option = {
          grid: {
            top: 20, // 离容器上边距离，默认 60
            right: 10, // 离容器右边距离，默认 '10%
            left: 80, // 离容器左边距离，默认 '10%'
            bottom: 20, // 离容器下边距离，默认 60
          },
          x: {
            name: ['t(s)'],
            nameStyle: {
              color: color.axis.name,
              size: '14px',
              bold: 'normal',
            },
            type: 'time',
            data: X,
            dataSymbol: XB, //有波形的点
            fontStyle: {
              color: color.axis.font,
              size: '14px',
            },
            lineStyle: {
              color: color.axis.line,
            },
            splitLineStyle: {
              color: color.axis.splitLine,
            },
          },
          y: {
            name: unitY,
            nameStyle: {
              color: color.axis.name,
              size: '14px',
              bold: 'normal',
            },
            data: Y,
            speed: Speed,
            fontStyle: {
              color: color.axis.font,
              size: '14px',
            },
            lineStyle: {
              color: color.axis.line,
            },
            splitLineStyle: {
              color: color.axis.splitLine,
            },
            /* 报警线 */
            markLine: alarmArr.length === 0 ? null : alarmArr,
          },
          series: {
            type: 'line', // 类型，默认 'line'
            lineStyle: {
              // 样式
              color: seriesColor, // 颜色，默认 '#0032ff
              width: 1, // 粗细，默认 1
            },
            posName,
            symbol: {
              show: false, //不显示
              color: color.series.symbol,
              size: 3,
            },
          },
          toolTip: {
            symbol: {
              show: true,
              color: color.tool.symbol,
              size: 3,
            },
            lineStyle: {
              // 标线样式
              color: color.tool.line, // 颜色，默认 '#FA9A4D'
              width: 1, // 粗细，默认 1
            },
            fontStyle: {
              // 标注字体样式
              color: color.tool.font, // 颜色，默认 '#fff'
              size: '14px', // 大小，默认 '12px'
              family: 'Microsoft YaHei', // 字体，默认 'Microsoft YaHei'
              weight: 'normal', // 粗细，默认 'normal'
            },
            background: {
              // 提示框背景
              color: color.tool.background, // 颜色，默认 'rgba(50, 50, 50, 0.3)'
            },
            formatter: (params) => {
              /* 其他谱图的联动 */
              Object.keys(this.charts).forEach((key) => {
                if (key != chart.chartId) {
                  this.charts[key].drawLineByX(params.val)
                }
              })
            }, // params = {key: number, val: number} =>  key: 下标，val: x 值
          },
        }
        /* 0关闭波形 1打开波形点 */
        if (getWave === 0) {
          option.series.symbol.show = false
          option.toolTip.dblHandler = Function.prototype // 取消回调函数
        } else if (getWave === 1) {
          option.series.symbol.show = true
          option.toolTip.dblHandler = (params) => {
            let time = params.val
            let idx = params.idx
            let item = pos_key_list[idx] //取到点击测点的key
            /* 存在测点，可以点击跳转 */
            if (item) {
              /* 如果这个点不是有波形的点，则不能跳转 */
              if (!item.wavePos.includes(time)) return
              let key = item.key
              let [macId, posId, posType] = key.split('_')
              let posArr = cloneObj(this.$store.state.pos[macId], true)
              let pos
              posArr.forEach((item) => {
                if (item.posFlag == key) {
                  pos = item
                }
              })
              /* 有些类型的测点不能跳转 */
              let flag = matchRule(posType, 'wave', pos.dgm_type, pos.t_root)
              if (!flag) {
                this.$pop('该测点没有波形图')
                return
              }
              /* 存储当前的时间点 */
              this.$store.commit('setCurrentTime', time)
              /* 获取波形图的key */
              key = 'wave_pos_' + key
              let name = '波形频谱图'
              let titleName = item.name + '波形频谱图'
              //跳转到波形图
              this.$bus.$emit('choiceChartType', key, name, titleName, true)
            }
          }
        }
        if (!this.charts[chart.chartId]) {
          let dom = document.getElementById(chart.chartId)
          this.charts[chart.chartId] = myChart.init(dom)
        }
        this.charts[chart.chartId].setOption(option)
        if (isResize) {
          /* 需要改变图谱的结构，在添加和删除图谱的时候 */
          /* 手动设置高 */
          // let dom = document.getElementById(chart.chartId);
          // // /* 重新设置dom 的长和宽 */
          // chartIns._dom.height = Math.round(dom.clientHeight);
          // chartIns._dom.weight = Math.round(dom.clientWidth);
          this.charts[chart.chartId].resize()
        }
      }
    },
    // 设置图谱dom高度
    setHeight(charts) {
      let len = 0
      charts.forEach((item) => {
        len++
      })
      let style = {
        height: `calc((100% - 50px) / ${len} - 1px)`,
        // height: "100px",
        marginTop: '1px',
      }
      len === 0 && delete style.marginTop
      return style
    },
    //拖入测点
    addPos(index, e) {
      const posMsg = JSON.parse(e.dataTransfer.getData('flag'))
      let key = `${posMsg.machine_id}_${posMsg.position_id}_${posMsg.position_type}`
      const chart = this.trendData[this.currentKey].chart[index]
      const type = posMsg.position_type
      const curType = chart.type
      const vibType = [3, 8]
      const spmType = [4, 9]
      if (
        (vibType.includes(curType) && !vibType.includes(type)) ||
        (spmType.includes(curType) && !spmType.includes(type)) ||
        curType !== type
      ) {
        /* 询问是否替换该测点 */
        if (type == 200) {
          this.$pop('该测点没有此图谱')
          return
        }
        this.$pop({ content: '加入不同类型测点，是否要替换', btnNum: 2 }).then(
          (res) => {
            if (res) {
              const defaultCode = getdefaultCode(posMsg.dgm_type)
              /* 替换 */
              let fileds = defaultCode[type]
              /* 重置这个chart */
              chart.count = 0
              chart.type = type
              chart.dgm_type = posMsg.dgm_type /* 计算特征值 */
              chart.t_root = posMsg.t_root /* 计算特征值 */
              chart.pos_loc = posMsg.pos_loc /* 计算特征值 */
              chart.code = fileds.code
              chart.value = fileds.filed
              chart.eName = fileds.name
              chart.data = {}
              this.add_pos(key, chart, posMsg)
            } else {
              return
            }
          }
        )
      } else if (chart.data[key]) {
        this.$pop('当前图谱已存在该测点')
        return
      } else {
        this.add_pos(key, chart, posMsg)
      }
    },
    // 生成随机颜色
    getColor(color) {
      let myColor = color || []
      let ml = myColor.length
      if (myColor !== undefined && ml > 0) {
        const cl = this.colorList
        const l = cl.length
        if (ml % l === 0) {
          myColor.push(cl[0])
        } else {
          let i = 0
          for (; i < l; i++) {
            const value = cl[i]
            if (myColor[ml - 1] === value) {
              myColor.push(cl[i + 1])
              break
            }
          }
          if (i === l) {
            myColor.push(cl[0])
          }
        }
      } else {
        myColor = [this.colorList[0]]
      }
      return myColor
    },
    // 关闭单张图谱
    closeOneChart(key, idx, chartId) {
      // this.$delete(this.charts, chartId); //删除chart实例
      // this.trendData[key].chart[idx].isDel = true;
      this.$delete(this.trendData[key].chart, idx)
      this.$nextTick(this.setOption)
    },

    // 设置谱线颜色
    setColor(index, idx, id, e) {
      const color = this.trendData[index].chart[idx].data[id].color
      const size = e.currentTarget.getBoundingClientRect()
      this.$color({
        pattern: {
          left: `${size.left}px`,
          top: `${size.top + size.height}px`,
        },
        color,
      }).then((res) => {
        this.trendData[index].chart[idx].data[id].color = res
        // this.$forceUpdate();
        this.setOption()
      })
    },
    // 数据检索
    dataRetrieval() {
      let isDataType = false
      const params = this.trendData[this.currentKey]
      let dataType = params.dataType
      if (params.chart[0].dgm_type == 11) {
        isDataType = true
      }
      let viewMsg = {
        isDataType,
        dataType,
      }
      this.$retrieval({
        key: 'trend',
        params: {
          cond: this.trendData[this.currentKey].cond,
          predTime: this.trendData[this.currentKey].predTime,
          alp: this.trendData[this.currentKey].alp,
        },
        viewMsg,
      }).then((res) => {
        if (res) {
          const rd = this.requestData
          rd.startTime = res.startTime
          rd.endTime = res.endTime
          rd.fromSpeed = res.minSpeed
          rd.toSpeed = res.maxSpeed
          rd.lowerLimit = res.lower
          rd.upperLimit = res.upper
          rd.density = Number(res.density.type)
          this.trendData[this.currentKey].cond = res.cond
          res.predTime &&
            (this.trendData[this.currentKey].predTime = res.predTime) //点击确定的时候也保存这些数据
          res.alp && (this.trendData[this.currentKey].alp = res.alp)
          let type
          res.trendPrediction ? (type = 2) : (type = 0) //0 历史数据 2 预测数据
          if (isDataType) {
            dataType = res.dataType //8000数据类型
            let dataTypeArray = []
            for (let i = 0; i < res.dataType.length; i++) {
              if (res.dataType[i].isChecked == true) {
                dataTypeArray.push(res.dataType[i].type)
              }
            }
            rd.dataType = dataTypeArray
          }
          this.getRequestParams(type, false)
        }
      })
    },
    /* 趋势预测 */
    transPredData(startTime, endTime, data) {
      //开始预测时间，结束预测时间，预测数据数组（100个）
      /* 将时间分成100分 */

      let tendencyList = []
      if (data.length && endTime > startTime) {
        // 存在趋势预测数据
        let interval = (endTime - startTime) / data.length
        for (let i = 0; i < data.length; i++) {
          tendencyList.push({
            saveTime: startTime + i * interval,
            tempValue: data[i],
          })
        }
      }
      return tendencyList
    },
    clearPredPos() {
      //清除预测数据的测点
      this.trendData[this.currentKey].chart.forEach((item) => {
        for (let key in item.data) {
          if (key.includes('_pred')) {
            // 预测测点的特征标志‘pred’
            this.$delete(item.data, key)
          }
        }
      })
    },
    /*
    右键显示菜单事件
    1.判断是否在图区域内
    2.若在区域内设定MenuShowflag = !showMenuflag
    3.设置右键菜单位置
    */
    showMenu(showMenuflag, index) {
      var event = event || window.event
      this.trendData[this.currentKey].chart[index].MenuShowflag = !showMenuflag
      var clickRightMenu = this.$refs[`${index}`]
      // 设置右键菜单位置
      clickRightMenu[0].style.top = event.offsetY + 'px'
      clickRightMenu[0].style.left = event.offsetX + 'px'
      return false
    },
    /*
    数据导出
    1.拼接数据
    2.转化为csv
    3.设定点击下载
    */
    dataInput(index) {
      this.trendData[this.currentKey].chart[index].MenuShowflag = false
      // 一个表的数据
      let trend = this.trendData[this.currentKey].chart[index]
      let type = Number(trend.type)
      let codeObj = getCodeObj(trend.dgm_type)
      const codeArr = codeObj[type]
      var eigenvalue = ''
      // 取特征值
      for (let i = 0; i < codeArr.length; i++) {
        if (trend.code === codeArr[i].code) {
          eigenvalue = codeArr[i].name
          break
        }
      }
      let myData = []
      let body = trend.data
      for (let key in body) {
        body[key].tendencyList.forEach((value) => {
          value.Time = getTime(value.saveTime)
          myData.push({
            测点名称: body[key].name,
            特征值: eigenvalue,
            x轴: value.Time,
            y轴: value.tempValue,
          })
        })
      }
      let fields = ['测点名称', '特征值', 'x轴', 'y轴']
      var Parser = require('json2csv').Parser
      let json2csvParser = new Parser({ fields })
      let csv = json2csvParser.parse(myData)
      csv = '\ufeff' + csv
      var aTag = document.createElement('a')
      var blob = new Blob([csv])
      aTag.download = '趋势图数据.csv'
      aTag.href = URL.createObjectURL(blob)
      aTag.click()
      URL.revokeObjectURL(blob)
    },
    /*
    保存图片
    1.获取document
    2.通过toDataURL画布里的图案转变成base64编码格式的png
     1>获取到一个canvas的对象数组picture
     2>将picture[0]赋值给canvas，并转为CanvasRenderingContext2D，
     将数组下标不为0的其他canvas用drawImage方法重叠
     3》最后将获得到的canvas转为base64编码格式的png
    */
    savePic(index) {
      this.trendData[this.currentKey].chart[index].MenuShowflag = false
      let chartId = this.trendData[this.currentKey].chart[index].chartId
      let picture = document.getElementById(chartId).lastChild
      new html2canvas(picture, {
        backgroundColor: this.savePicBackgroundColor,
        useCORS: true,
        scale: 0.5,
      }).then((canvas) => {
        let downLoad = document.createElement('a')
        downLoad.href = canvas.toDataURL()
        downLoad.download = '趋势图.png'
        downLoad.dispatchEvent(new MouseEvent('click'))
      })
    },
    resizeChart() {
      let chart = this.charts
      let currentChart = this.trendData[this.currentKey].chart
      currentChart.forEach((item) => {
        chart[item.chartId] && chart[item.chartId].resize()
      })
    },
  },
  created() {
    /* 浏览器页面改变 刷新图谱 */
    window.addEventListener('resize', this.resizeChart)
    this.initSrcParams()
    this.$store.commit('set_keepAlive', { method: 'add', keepAlive: 'trend' })
  },
  destroyed() {
    window.removeEventListener('resize', this.resizeChart)
  },
}
</script>
